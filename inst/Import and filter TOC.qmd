---
title: "Import and Filter TOC LEEF-2"
format: 
  html:
    toc: true
    toc-location: left
    code-fold: true
    code-summary: "Show the code"
    embed-resources: true
    standalone: true
    output-dir: "/Volumes/LEEF/0.TOC/LEEF-2/"
    output-file: "Import and Filter TOC from LEEF-2"
    output-ext:  "html"
editor: source

---

## Some preliminary setup



```{r}
#| label: setup
#| eval: true
library(LEEF.analysis)
library(LEEF.measurement.toc)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggExtra)
options(dplyr.summarise.inform = FALSE)
```

```{r}
# root_folder <- "/Volumes/LEEF/0.TOC/LEEF-1/"
root_folder <- "/Volumes/LEEF/0.TOC/LEEF-2/"

db <- file.path(root_folder, "9.backend", "LEEF-2.RRD.TOC.sqlite")
options(RRDdb = db)

pre_processor_toc(file.path(root_folder, "0.raw.data"), file.path(root_folder, "1.pre-processed.data"))
extractor_toc(file.path(root_folder, "1.pre-processed.data"), file.path(root_folder, "2.extracted.data"))

# pre_processor_toc("/Volumes/LEEF/0.TOC/LEEF-2/0.raw.data/", "/Volumes/LEEF/0.TOC/LEEF-2/1.pre-processed.data/")
# extractor_toc("/Volumes/LEEF/0.TOC/LEEF-2/1.pre-processed.data//", "/Volumes/LEEF/0.TOC/LEEF-2/2.extracted.data//")

```

## Read parameter and data files and determine CV and number extra measurements
```{r}
#| label: parameter

fns <- sapply(
  list.files(file.path(root_folder, "2.extracted.data", "toc"), "\\.data\\.", full.names = FALSE),
  function(fn){
    x <- strsplit(fn, "\\.")[[1]][[1]]
  }
)

data <- lapply(
    fns,
    function(fn){
      p <- read.csv(file.path(root_folder, "2.extracted.data", "toc", paste(fn, "parameter", "csv", sep = ".")))
      d <- read.csv(file.path(root_folder, "2.extracted.data", "toc", paste(fn, "data", "csv", sep = ".")))
      return(list(
        data = d, 
        parameter = p, 
        samples = max(p$samples), 
        extra_samples = max(p$extra_samples), 
        max_cv = max(p$max_cv)
      )
      )
    }
)

sapply(data, "[[", "samples") |> plot(ylab = "samples") |> print()
sapply(data, "[[", "extra_samples") |> plot(ylab = "extra_samples") |> print()
sapply(data, "[[", "max_cv") |> plot(ylab = "max_cv") |> print()

samples <- sapply(data, "[[", "samples") |> min()
extra_samples <- sapply(data, "[[", "extra_samples") |> min()
max_cv <- sapply(data, "[[", "max_cv") |> max()

no_samples <- samples + extra_samples
max_col <- (2 + 3 + no_samples * 2) + 1
      
```

As the number of additional samples as well as the cv were different for some samples, we have to re-calculate conc and cv. The values which will be used are

- **samples**: `r samples`
- **extra_samples**: `r extra_samples`
- **max_cv**: `r max_cv`

In case there are more extra samples, the last ones were be discarded.


## Read data and adjust different number of samples and cv
```{r}
#| label: data
toc <- lapply(
  data,
  function(x){
    result <- x$data[,1:max_col]
    return(result)
  }
) |> do.call(what = rbind)
toc$id <- 1:nrow(toc)
```


## Remove missing `inj_type`

We have the following measurements files with measurements without inj_type or `NULL.

```{r}
toc %>%
  filter(inj_type == "") %>%
  group_by(filename) %>%
  summarise(n = n()) %>% 
  collect() %>%
  knitr::kable()
```

These can be filtered out

```{r}
before <- nrow(toc)
toc <- toc %>%
  filter(inj_type != "")
after <- nrow(toc)
cat("Before : ", before, "\n")
cat("Removed: ", before - after, "\n")
cat("After  : ", after, "\n")
```

## Remove Rows where `conc == 0`
Here it gets tricky. There are cases, where either `conc_1 == 0` or `conc_2 == 0`, but `conc_3 != 0`, which results in a valid measurement, i.e. `conc != 0`. I would suggest to remove all rows, in which `conc == 0`

```{r}
toc %>%
  filter(conc == 0) %>%
  group_by(filename) %>%
  summarise(n = n()) %>% 
  collect() %>%
  knitr::kable()
```

```{r}
before <- nrow(toc)
toc <- toc %>%
  filter(conc > 0)
after <- nrow(toc)
cat("Before : ", before, "\n")
cat("Removed: ", before - after, "\n")
cat("After  : ", after, "\n")
```

## Check timestamp / id / Filename

In each file, there should be a maximum of 2 timestamps, except of files which contain two timestamps.

```{r}
toc %>%
  select(filename, timestamp, identification, inj_type) %>%
  filter(identification != "H2O" & identification != "2.5mg/lIC") %>%
  group_by(filename, timestamp) %>%
  summarise(timestamps_count = n()) %>%
  group_by(filename) %>%
  summarise(number_of_timestamps = n()) %>%
  arrange(desc(number_of_timestamps)) %>%
  knitr::kable()
```

Fixed two typos in the raw data. Now, it looks OK for me. 

- `LEEF_21_11_12`: "Analysis Name","LEEF_21_11_12 und 21_15_10A.adb"
- `LEEF_22_01_19 und 22_01_21A`: All analysis for 22_01_21 are not valid

## Set unrealistic small TC values to `NA`
```{r}
tc <- toc %>%
  filter(inj_type == "TC")
tc <- data.frame(conc_TC = c(tc$conc_1, tc$conc_2, tc$conc_3))
tc %>% ggplot(aes(x=conc_TC)) + 
  stat_density(bw = 0.1, na.rm = TRUE) +
  geom_vline(xintercept = 5, col = "red")
```
One can see for TC two peaks clearly separated. The values smaller than 5 will be set to `NA` as they are unrealistically low and can be traced to measuring errors in the machine.

```{r}
tc <- toc$inj_type == "TC"
toc$conc_1[tc & sapply(toc$conc_1 < 5, isTRUE)] <- NA
toc$conc_2[tc & sapply(toc$conc_2 < 5, isTRUE)] <- NA
toc$conc_3[tc & sapply(toc$conc_3 < 5, isTRUE)] <- NA

```

Which are now gone

```{r}
tc <- toc %>%
  filter(inj_type == "TC")
tc <- data.frame(conc_TC = c(tc$conc_1, tc$conc_2, tc$conc_3))
tc %>% ggplot(aes(x=conc_TC)) + 
  stat_density(bw = 0.1, na.rm = TRUE) +
  geom_vline(xintercept = 5, col = "red")
```

# Set unrealistic small IC values to `NA`
```{r}
tc <- toc %>%
  filter(inj_type == "IC")
tc <- data.frame(conc_IC = c(tc$conc_1, tc$conc_2, tc$conc_3))
tc %>% ggplot(aes(x=conc_IC)) + 
  geom_vline(xintercept = 0.7, col = "red") +
  stat_density(bw = 0.001, na.rm = TRUE)
```
One can see for TC two peaks clearly separated. The values smaller than 5 will be set to `NA` as they are unrealistically low and can be traced to measuring errors in the machine.

```{r}
tc <- toc$inj_type == "IC"
toc$conc_1[tc & sapply(toc$conc_1 < 0.7, isTRUE)] <- NA
toc$conc_2[tc & sapply(toc$conc_2 < 0.7, isTRUE)] <- NA
toc$conc_3[tc & sapply(toc$conc_3 < 0.7, isTRUE)] <- NA

```

Which are now gone

```{r}
tc <- toc %>%
  filter(inj_type == "TC")
tc <- data.frame(conc_TC = c(tc$conc_1, tc$conc_2, tc$conc_3))
tc %>% ggplot(aes(x=conc_TC)) + 
  stat_density(bw = 0.001, na.rm = TRUE) +
  geom_vline(xintercept = 5, col = "red")
```



## Recalculate `conc` and TOC
As the number of additional samples as well as the cv were different for some samples, we have to re-calculate conc and cv. The values which will be used are
- **samples**: `r samples`
- **extra_samples**: `r extra_samples`
- **max_cv**: `r max_cv`
In case there are more extra samples, the last ones were be discarded.

In addition, we have calculate the TOC, which is `TOC = TC - IC`

Now we calculate `conc`

```{r}
#| label: calc_conc_cv
conc_ext <- function(c1, c2, c3, cv, max_cv){
  cvf <- function(x, y){
    sapply(
      1:length(x),
      function(i){
        sd(c(x[i], y[i])) / mean(c(x[i], y[i])) * 100
      }
    )
  }
  
  conc_org <- cv < max_cv

  conc_13 <- cvf(c1, c3) < max_cv
  conc_13[conc_org] <- FALSE
  
  conc_23 <- !conc_13
  conc_23[conc_org] <- FALSE
  
  conc <- c1
  conc[] <- NA
  
  conc[which(conc_org)] <- rowMeans(data.frame(c1[which(conc_org)], c2[which(conc_org)]))
  conc[which(conc_13) ] <- rowMeans(data.frame(c1[which(conc_13)],  c2[which(conc_13) ]))
  conc[which(conc_23) ] <- rowMeans(data.frame(c1[which(conc_23)],  c2[which(conc_23) ]))

  return(conc)
}

toc$conc_old <- toc$conc
toc$conc <- conc_ext(toc$conc_1, toc$conc_2, toc$conc_3, toc$cv, max_cv)

i <- which(toc$inj_type == "TOC")
toc$conc[i] <- NA

TOC_calc <- toc %>% 
  mutate(an_id = paste(filename, position)) %>%
  pivot_wider(id_cols = an_id, names_from = inj_type, values_from = conc) %>%
  mutate(TOC_calc = TC - IC) %>%
  select(an_id, TOC_calc) %>%
  mutate(an_id = paste(an_id, "TOC"))

toc <- toc %>% 
  mutate(an_id = paste(filename, position, inj_type)) %>%
  left_join(TOC_calc, by = "an_id") %>%
  mutate( conc = ifelse(inj_type == "TOC", TOC_calc, conc) ) %>%
  select( -TOC_calc, -an_id)
```




And the plot again after re-calculation of the TOC values
```{r}
toc %>% 
  ggplot(aes(x=conc)) + 
  stat_density(bw = 0.1, na.rm = TRUE) +
  facet_grid(rows = vars(inj_type), scales = "free_y")
```


## Add to database

The toc is now added to the database
```{r}
#| label: add_to_dv

add_to_and_overwrite_table_in_RRD(toc = toc, dbname = db, overwrite = TRUE)

toc_original <- toc

toc$id <- 1:nrow(toc)
```




## Plot after filtering
Now let's look at the plots of the measurements per bottle per timestep
```{r}
plot_tocs_per_bottle_per_timestamp(db = db, c("TC", "TOC"))
plot_tocs_per_bottle_per_timestamp(db = db, c("IC"))
plot_tocs_per_bottle_per_timestamp(db = db, c("TN"))
```



## Number of measurements per `timestamp`, `bottle` and `inj_type`

We have to look if there are any duplicate measurements. 

```{r}
dupl <- toc %>%
  group_by(timestamp, bottle, inj_type) %>%
  filter(!is.na(bottle)) %>%
  summarise(fn_1 = min(filename), fn_2 = max(filename), count = n(), min_conc = min(conc), max_conc = max(conc)) %>%
  filter(count > 1 & count < 10) %>%  
  mutate(diff = max_conc - min_conc) %>%
  arrange(inj_type, diff)
dupl %>% 
  group_by(fn_1, fn_2, timestamp) %>%
  summarise() %>%
  arrange(timestamp) %>%
  knitr::kable()
```

And some plots of the duplicate concentration values only
```{r}
dat <- db_read_toc(db = db, duplicates = NULL) %>% 
  collect()
if (nrow(dat) > 0){
dat$id <- 1:nrow(dat)
ids <- dat %>% 
  filter(!is.na(bottle)) %>%
  group_by(timestamp, bottle, type) %>%
  summarize(min(id), max(id), n = n()) %>%
  filter(n > 1)
ids <- c(ids$`min(id)`, ids$`max(id)`) |>
  unique()
x <- dat %>% 
  filter(id %in% ids) %>%
  group_by(day, timestamp, bottle, type) %>%
  summarise(timestamp, bottle, type, mic = min(concentration), mac = max(concentration)) %>%
  mutate(mdiff = mac - mic)
}
```
### TN Duplicates

```{r}
if (nrow(dat) > 0){
  pl <- x %>%
    filter(type == "TN") %>%
    ggplot2::ggplot(ggplot2::aes(x = mic, y = mac, colour = type)) +
    ggplot2::geom_point() +
    ggplot2::xlab("Smaler concentration Value") +
    ggplot2::ylab("Larger concentration Value")
  
  ggMarginal(pl, type="histogram")
}
```
### TC Duplicates

```{r}
if (nrow(dat) > 0){
  pl <- x %>%
    filter(type == "TC") %>%
    ggplot2::ggplot(ggplot2::aes(x = mic, y = mac, colour = type)) +
    ggplot2::geom_point() +
    ggplot2::xlab("Smaler concentration Value") +
    ggplot2::ylab("Larger concentration Value")
  
  ggMarginal(pl, type="histogram")
}
```


### IC Duplicates

```{r}
if (nrow(dat) > 0){
  pl <- x %>%
    filter(type == "IC") %>%
    ggplot2::ggplot(ggplot2::aes(x = mic, y = mac, colour = type)) +
    ggplot2::geom_point() +
    ggplot2::xlab("Smaler concentration Value") +
    ggplot2::ylab("Larger concentration Value")
  
  ggMarginal(pl, type="histogram")
}
```

### TOC Duplicates

```{r}
if (nrow(dat) > 0){
  pl <- x %>%
    filter(type == "TOC") %>%
    ggplot2::ggplot(ggplot2::aes(x = mic, y = mac, colour = type)) +
    ggplot2::geom_point() +
    ggplot2::xlab("Smaler concentration Value") +
    ggplot2::ylab("Larger concentration Value")
  
  ggMarginal(pl, type="histogram")
}
```


