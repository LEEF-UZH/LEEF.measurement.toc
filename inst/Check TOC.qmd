---
title: "Check TOC"
format: 
  html:
    toc: true
    toc-location: left
    code-fold: true
    code-summary: "Show the code"
    self-contained: true
editor: source

---

## Some preliminary setup

```{r}
#| eval: FALSE
```

```{r}
#| label: setup
#| eval: true
library(LEEF.analysis)
library(dplyr)
library(ggplot2)
options(dplyr.summarise.inform = FALSE)
```

```{r}
unlink(c("~/Desktop/1.pre-processed.data/toc/", "~/Desktop/2.extracted.data/toc/"))
LEEF.measurement.toc::pre_processor_toc("~/Desktop/0.raw.data/", "~/Desktop/1.pre-processed.data/")
LEEF.measurement.toc::extractor_toc("~/Desktop/1.pre-processed.data/", "~/Desktop/2.extracted.data/")
LEEF.measurement.toc::add_to_and_overwrite_table_in_RRD("~/Desktop/2.extracted.data/", "~/Desktop/9.backend/toc.sqlite", overwrite = TRUE)


db <- "~/Desktop/9.backend/toc.sqlite"
options(RRDdb = db)

toc <- LEEF.analysis::db_read_table(table = "toc__toc") %>%
  collect()

toc_original <- toc

conn <- DBI::dbConnect(
  drv = RSQLite::SQLite(),
  db = "~/Desktop/9.backend/toc.sqlite"
)

DBI::dbBegin(conn)
DBI::dbWriteTable(
  conn,
  name = "toc__toc_original",
  value = toc,
  overwrite = TRUE,
  append = FALSE
)
DBI::dbCommit(conn)

DBI::dbDisconnect(conn)

toc$id <- 1:nrow(toc)
```



## Remove missing `inj_type`

We have the following measurements files with measurements without inj_type or `NULL.

```{r}
toc %>%
  filter(inj_type == "") %>%
  group_by(filename) %>%
  summarise(n = n()) %>% 
  collect() %>%
  knitr::kable()
```

These can be filtered out

```{r}
before <- nrow(toc)
toc <- toc %>%
  filter(inj_type != "")
after <- nrow(toc)
cat("Before : ", before, "\n")
cat("Removed: ", before - after, "\n")
cat("After  : ", after, "\n")
```

## Rows where `conc == 0`
Here it gets tricky. There are cases, where either `conc_1 == 0` or `conc_2 == 0`, but `conc_3 != 0`, which results in a valid measurement, i.e. `conc != 0`. I would suggest to remove all rows, in which `conc == 0`

```{r}
toc %>%
  filter(conc == 0) %>%
  group_by(filename) %>%
  summarise(n = n()) %>% 
  collect() %>%
  knitr::kable()
```

```{r}
before <- nrow(toc)
toc <- toc %>%
  filter(conc > 0)
after <- nrow(toc)
cat("Before : ", before, "\n")
cat("Removed: ", before - after, "\n")
cat("After  : ", after, "\n")
```

## Check timestamp / id / Filename

In each file, there should be a maximum of 2 timestamps, except of files which contain two timestamps.

```{r}
toc %>%
  select(filename, timestamp, identification, inj_type) %>%
  filter(identification != "H2O" & identification != "2.5mg/lIC") %>%
  group_by(filename, timestamp) %>%
  summarise(timestamps_count = n()) %>%
  group_by(filename) %>%
  summarise(number_of_timestamps = n()) %>%
  arrange(desc(number_of_timestamps)) %>%
  knitr::kable()
```

Fixed two typos in the raw data. Now, it looks OK for me. 

- `LEEF_21_11_12`: "Analysis Name","LEEF_21_11_12 und 21_15_10A.adb"
- `LEEF_22_01_19 und 22_01_21A`: All analysis for 22_01_21 are not valid

## Identify TOC measurements which are based on missing IC or TC measurements
We have to identify and remove the TOC measurements which are using wrong measurements, i.e. TC or IC not available.

The following rows need to be removed:
```{r}
inj_type <- list(
  tc = toc %>%
    filter(inj_type == "TC" & bottle != "") %>%
    select(filename, timestamp, bottle, conc_tc = conc, id_tc = id),
  ic = toc %>%
    filter(inj_type == "IC" & bottle != "") %>%
    select(filename, timestamp, bottle, conc_ic = conc, id_ic = id),
  toc = toc%>%
    filter(inj_type == "TOC" & bottle != "") %>%
    select(filename, timestamp, bottle, conc_toc = conc, id_toc = id),
  tn = toc%>%
    filter(inj_type == "TN" & bottle != "") %>%
    select(filename, timestamp, bottle, conc_tn = conc, id_tn = id)
)
x <- merge(inj_type$tc, inj_type$ic, by = c("filename", "timestamp", "bottle"), all = TRUE)
x <- merge(x, inj_type$toc, by = c("filename", "timestamp", "bottle"), all = TRUE)
x <- merge(x, inj_type$tn, by = c("filename", "timestamp", "bottle"), all = TRUE)
x$TOC <- x$conc_tc - x$conc_ic

i <- x[is.na(x$TOC),"id_toc"]
toc[toc$id %in% i,]
```
These can be filtered out

```{r}
before <- nrow(toc)
toc <- toc %>%
  filter(!(id %in% i))
after <- nrow(toc)
cat("Before : ", before, "\n")
cat("Removed: ", before - after, "\n")
cat("After  : ", after, "\n")
```



## Plot before filtering
```{r}
plot_tocs_per_bottle_per_timestamp(db = db, c("TC", "TOC"))
plot_tocs_per_bottle_per_timestamp(db = db, c("IC"))
plot_tocs_per_bottle_per_timestamp(db = db, c("TN"))
```

## Apply the filters to the database

```{r}
#| eval: TRUE
conn <- DBI::dbConnect(
  drv = RSQLite::SQLite(),
  db = db
)

DBI::dbBegin(conn)
DBI::dbWriteTable(
  conn,
  name = "toc__toc",
  value = toc,
  overwrite = TRUE,
  append = FALSE
)
DBI::dbCommit(conn)

DBI::dbDisconnect(conn)
```


## Plot after filtering
```{r}
plot_tocs_per_bottle_per_timestamp(db = db, c("TC", "TOC"))
plot_tocs_per_bottle_per_timestamp(db = db, c("IC"))
plot_tocs_per_bottle_per_timestamp(db = db, c("TN"))
```


## Distribution of the individual values per `inj_type`
Calculate the densities
```{r}
x <- toc %>%
  filter
conc <- list(
  tc = list(
    original = toc_original$conc[toc$inj_type == "TC" | !is.null(toc$bottle)] |> density(bw = 0.1, na.rm = TRUE),
    removed  = toc$conc[toc$inj_type == "TC" | !is.null(toc$bottle)] |> density(bw = 0.1)
  ),
  toc = list(
    original = toc_original$conc[toc$inj_type == "TOC" | !is.null(toc$bottle)] |> density(bw = 0.1, na.rm = TRUE),
    removed  = toc$conc[toc$inj_type == "TOC" | !is.null(toc$bottle)] |> density(bw = 0.1)
  ),
  ic = list(
    original = toc_original$conc[toc$inj_type == "IC" | !is.null(toc$bottle)] |> density(bw = 0.1, na.rm = TRUE),
    removed  = toc$conc[toc$inj_type == "IC" | !is.null(toc$bottle)] |> density(bw = 0.1)
  ),  
  tn = list(
    original = toc_original$conc[toc$inj_type == "TN" | !is.null(toc$bottle)] |> density(bw = 0.1, na.rm = TRUE),
    removed  = toc$conc[toc$inj_type == "TN" | !is.null(toc$bottle)] |> density(bw = 0.1)
  )
)
```

### TC

```{r}
plot(conc$tc$removed, col = "red")
lines(conc$tc$original)
```

### TOC

```{r}
plot(conc$toc$removed, col = "red")
lines(conc$toc$original)
```

### IC

```{r}
plot(conc$tc$removed, col = "red")
lines(conc$tc$original)
```

### TN

```{r}
plot(conc$tn$removed, col = "red")
lines(conc$tn$original)
```

## Number of measurements per `timestamp`, `bottle` and `inj_type`

We have to look if there are any duplicate measurements. 

```{r}
dupl <- toc %>%
  group_by(timestamp, bottle, inj_type) %>%
  filter(!is.na(bottle)) %>%
  summarise(fn_1 = min(filename), fn_2 = max(filename), count = n(), min_conc = min(conc), max_conc = max(conc)) %>%
  filter(count > 1 & count < 10) %>%  
  mutate(diff = max_conc - min_conc) %>%
  arrange(inj_type, diff)
dupl %>% 
  group_by(fn_1, fn_2, timestamp) %>%
  summarise() %>%
  arrange(timestamp) %>%
  knitr::kable()
```

And some plots
```{r}
x <- plot_tocs_per_bottle_per_timestamp()
dat <- x$data
dat$id <- 1:nrow(dat)
ids <- dat %>% 
  filter(!is.na(bottle)) %>%
  group_by(timestamp, bottle, type) %>%
  summarize(min(id), max(id), n = n()) %>%
  filter(n > 1)
ids <- c(ids$`min(id)`, ids$`max(id)`) |>
  unique()
dat <- dat %>% filter(id %in% ids)


pl <- dat %>% ggplot(aes(x=concentration)) + 
  stat_density(bw = 1) +
  facet_grid(rows = vars(type))
pl

x <- dat %>%
  group_by(day, timestamp, bottle, type) %>%
  summarise(timestamp, bottle, type, mic = min(concentration), mac = max(concentration)) %>%
  mutate(mdiff = mac - mic)

x %>%  
  ggplot2::ggplot(ggplot2::aes(x = day, y = mic, colour = type)) +
  ggplot2::geom_point() +
  ggplot2::facet_grid(rows = vars(type), scales = "free_y") +
  ggplot2::scale_colour_manual(values = 1:40) +
  ggplot2::xlab("Day of Experiment") +
  ggplot2::ylab("concentration") +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45))
 
x %>%  
  ggplot2::ggplot(ggplot2::aes(x = mic, y = mac, colour = type)) +
  ggplot2::geom_point() +
  ggplot2::xlab("Smaler concentration Value") +
  ggplot2::ylab("Larger concentration Value")

table(x$mic)
```

# TODO: CHECK WHERE THE AVERAGE IS COMING IN IN FLOWCYTOMETER!
# extract or view?


